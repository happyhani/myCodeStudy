<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title></title>
	</head>
	<body>
	问：  1、创建对象的方式？为考察原型链、面向对象打基础
	  2、原型、构造函数、实例、原型链 是什么？
	  3、instanceof的原理
	  4、new运算符
	
	<script> 
	  答：  1、proto.html
	  字面量:var o1 = {name:'o1'}; // 原型链指向object
	      var o11 = new Object({name: 'oo1'});
	显示的构造函数:  var M = function (name) { this.name=name }
	            var o2 = new M('o2');
	创建空对象:        
	        var P = {name:'o3'};
	        var o3 = Object.create(P);
	  
	原型: 构造函数的prototype属性指向原型对象.
	构造函数: 原型对象的constructor属性指向构造函数.
	实例: 构造函数通过new可以创建实例.
	原型链:顶端是Object.__proto__
	
	在原型对象上增加属性和方法,通过原型链的方式,实例对象可以找到原型对象的方法.原型对象上的方法和属性都是被实例所共享的.
	注意:函数有prototype,实例对象有__proto__
	  但是函数也是对象: M.__proto__ === Function.prototype //true
	  
	3、instanceof的原理:
  	是判断实例对象的__proto__和构造函数的prototype是否引用同一个对象.
  	只要在原型链上的构造函数都会被看做是o3的构造函数.
  	M.prototype.__proto__ === Object.prototype // true 
  	
  4/new运算符:
    一个新对象被创建.他继承自foo.prototype
    构造函数foo被执行.执行的时候,相应的参数会被传入,同时上下文(this)会被指定为这个新实例.new foo等同于new foo(),只能用在不传递任何参数的情况.注:如果不执行,构造函数以及构造函数体内的this都是执行不了的.要将构造函数的this上下文转到新对象上
    如果构造函数返回了一个'对象',那么这个对象会取代整个new出来的结果.如果构造函数没有返回对象,那么new出来的结果为步骤1创建的对象
	</script>
	</body>
</html>
