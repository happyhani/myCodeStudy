###Welcome to use MarkDown


## 2-1 面试及环节设置

* 社招：（2-3年的人）
知识 ：协议 对业务的认知和把控程度
能力：架构、对业务的把控能力、对组件的抽象能力。更看重把控能力，能不能带领2-3人快速提高开发效率以及产品的稳定性
经验：有这个能力，那就是经验了。

* 面试环节的设置：
一面：基础知识（HTML css js）
二面/三面：高级工程师/资深工程师 问基础之上的延伸，问你原理。没有标准，看你怎么引导他。根据你的经历 你擅长的。例如：我用vue做了什么什么。先问项目再会落脚到vue上，vue的生命周期是什么，工作原理是什么，有没有看过他的源码，他的源码有什么缺点，让你改进你怎么改进，他的框架有什么优点，等等
三面/四面：技术负责人/业务负责人 不再关注技术点了而是关注你在职业生涯的从业方面，有没有做过什么特色的业务。在某个业务上做过哪些事情，你的角色是什么，你推动了什么，你改变了什么。他更想听这方面的故事。他要知道你的历史来判断你在这个岗位上你能做出什么成绩来。
hr终面：看中沟通 潜力 性格。技术生涯的潜力和业务上的潜力

## 2-2 2-3 职位分析（JD）
初衷：当前岗位是不是你所喜欢的，当前岗位你是不是能hold住，在短期内准备能不能hold住。
职位分析（JD）分析
* 职位描述：（工作职责）
1、pc端 移动端双方面的知识
2、App H5开发：hybird开发 纯H5开发就是跟native客户端没有交互的(有动画的活动页专题页)
3、调试数据接口 模拟数据 与UI 产品 后台的沟通
4、负责京东金融前端组件库的建立 （难度设立：1、基本功扎实原生js css理解是否到位2、之前有没有前端组件库设立的经验3、是否通读过其他的UI组件库）本条大于前3条，前3条是基础工作1 2年都可以胜任
5、对现有系统的优化与重构（考察你的方案）
* 任职要求：（技术深度 技术能力 工作能力）
1、HTML5最新规范 要求对新知识的关注
2、js面向对象 原型链等
3、web最新标准 数据与表现分离 HTML语义化 vue实际经验，要准备在开发过程中遇到的问题
4、前端架构分析与设计能力：可以拿之前做过的项目 目录结构怎么设计 复用性怎么设计 模块化怎么设计 自动化测试怎么测 上下流是什么
5、用户可用性、用户体验、用户研究等：例如是按钮，不光是完成任务，还要测试留不流畅 卡不卡等。这么说：我这么做是完成了功能，我又做了哪些改进，增强了用户体验
6、对前端有强烈兴趣：浏览github上排名靠前的前端项目都在用什么新技术，看技术博客。当问你的时候，你要能说出1 2 3来
7、css预编译
8、能够自己搭建前端构建环境gulp。grunt和gulp的区别，为什么用gulp而不用grunt。
9、某某优先的不是必备项，如果准备的充分可以说


## 2-4 2-5 业务分析或实战模拟
1、js的异步加载方式有？
2、模块加载机制，传统的模块处理方式有几种？requireJS是一种，在现有的框架中是怎么处理模块化的，es6中是怎么处理模块化的？了解requireJS和Sea.js的区别？
3、使用了CDN加速。静态域：专门放静态资源的CDN域
4、和技术栈配套的是最常用的：jq中操作大片DOM片段几乎是借用模板的。模板比较好的：Hanldebars(基于Mustache构建而成)、Underscore Templates 、 Embedded JS（EJS）
5、查看页面的布局，自己动手尝试。
6、打开调试面板 element查看meta标签  sources中查看用到的技术栈
`
<meta name="format-detection" content="telephone=no,email=no"> 是关闭页面中数字自动识别为电话 邮箱
<link href="//yfd1.fbcontent.cn" rel="dns-prefetch"> dns预解析 提升性能
<meta http-equiv="X-UA-Compatible" content="IE=Edge, chrome = 1"> 网页兼容
<meta name="renderer" content="webkit"> 双核浏览器下 优先使用webkit内核
<meta name="force-rendering" content="webkit"> 第一次浏览时，浏览器就忽略内置名单及用户选择，强制用WebKit内核。
<meta name="mobile-agent" content="format=html5; url=https://m.yuanfudao.com/?keyfrom=apeOfficialWebsite&amp;vendor=apeOfficialWebsite">  
`
pc端是www.yuanfudao.com 移动端是m.yuanfudao.com
url=/m：代表当前PC页所对应的手机页/m，两者必须是一一对应关系（而不是统一对应至手机站首页）前提是你需要做两套网站，一套是在pc端访问的（假如网址是www.baidu.com），一套是在手机端访问的（假如网址是m.baidu.com），这句就是判断如果你是在手机上打开的这个网站那就会打开m.baidu.com这个网址，但是默认打开的是www.baidu.com


## 2-6 技术栈准备
* jq的源码：核心架构、事件委托是怎么实现的 插件机制。兼容性可以去看。看jq的博客，过一遍
* vue react angualr精通一个，了解1 2个，不要说3个都行。
* node如果没做过，不要求就不要说了。
* 前端工程：sass less gulp grunt npm webpack browserify 
* gulp和grunt的区别，没用的话就直接使用gulp。
* npm 常用命令和 npmscripts
* rollup 打包：比较小众 适合打包npm

## 2-7 面试准备-自我陈述
自我介绍：
简历:
1. 基本信息，姓名-年龄-手机-邮箱-籍贯
2. 学历
3. 工作经历，时间-公司-岗位-职责-技术栈-业绩
4. 开源项目，github和说明
> 当在工作岗位上没有做出什么业绩：技巧是重新梳理当时什么地方没做好，再想出一套技术方案来，最好是用代码去实现一遍。将最新研究出的方案写在简历中，作为在工作职责上所做出的产出，也就是攻克的技术难点。
> 面试官真正关心的是哪个技术方案解决了哪个技术问题
> 开源项目捷径：在github上找流行的开源项目，去参与这些项目，但是不能作假

#### 自我陈述:
1. 把握面试的沟通方向
##### 要善于掌握，你应该说什么不该说什么，因为面试官在你回答完后已经准备好了问题问你
* 帮我的实验室导师做过什么什么项目
> 作为面试官听的点是：你做过什么项目，这个项目是做什么的，和我们前端的结合点是什么，他的角色是什么，他在这个项目中承担的责任是什么，他做出了哪些成绩？
* 我在实验室里我是负责人
> 这句话吸引人的点是负责人。1、你的项目有几个人参与 2、你这个负责人起了一个什么样的角色，是项目管理还是技术管理 3、你做出了什么样的成绩
> 项目大的话会问很多问题，问到各种细节，你的项目是怎么分配的，团队间是怎么协作的，技术管理上是怎么解决技术配合的，技术难点是怎么解决的额
> 可以这么说：我平时喜欢研究网站，看他们的技术原理，和好玩的点，我愿意思考，也愿意尝试有没有更好的方式。这时候停一下，不要再往下说了。这时候面试官会问你，你会去看什么，这是一个正向的沟通。多准备几个点。
2. 豁达、自信的适度发挥
* 豁达：说话不要唯唯诺诺。
* 自信：不要担心他问你的你不会，这样气场就下来了。
* 不要膨胀，让他欣赏你就行。

## 2-8 自我陈述
#### 实例：
* 自如谈兴趣 巧妙示实例 适时讨疑问
* 节奏要适宜、切忌小聪明
> 适时讨疑问：回答了1 2问，第三问往往会比较难，这时要说我不懂我要回去思考一下。面试官能不能指点一下，我在这方面确实没有经验，或给什么什么建议，有什么参考资料，我回去弄懂它。
> 节奏要适宜、切忌小聪明：回答问题要坦诚，不要觉得这么简单的问题还问我，节奏要放平缓。例如实现页面布局，写出1-2种只能叫实现。但是写出4-5种是对技术的追求
#### 实战：
* 方向要对、过程要细
* 胆子要大、心态要和
> 方向要对：例如要求做优化，即使是你没有做过优化。但是你可以提供优化方案。如果能说的越细越好。
> 胆子要大：例如公司出了一个很难的算法题，不要还没看就放弃。这对所有人都难，但是你表现出了思维独特，视角独特，那你也就成功了。
> 心态要和：都答对了也要不要飘飘然，当遇到问到的问题都不会了的话，也不要气馁。这样会导致面试提前终止。这时要想办法在这次面试中得到点什么，不要轻易放弃，多向面试官问些问题。是类似于请教一样，我该看什么资料去补这块的知识点。问面试官，我补完了还能再来面试吗？
> 面试失败了，自己回去把知识体系补全了，再回来，公司依然会接收你。
> 这些比知识本身更重要，这是决定结果的时候。好好体会这个方法和技巧。

## 3-1 页面布局一
一面：
准备要充分
通信：跨域通信，普通前后端通信
安全：CSRF（Cross-site request forgery）跨站请求伪造，也被称为“One Click Attack”或者Session Riding，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用 
    XSS 跨站脚本攻击(Cross Site Scripting)，为了不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故将跨站脚本攻击缩写为XSS。
算法

## 3-2 页面布局二
页面布局：
1、这个题真像想象的这么简单吗？如果只说浮动和定位那还没有及格 
2、 5种方式，并给出html是和css 
3、如何去拔高,去延伸。1)这5种方案各自有什么优缺点。2)把高度已知去掉，也就是高度自适应，这几种方案哪个还适用。3)兼容性如何
中间内容自动适应原理：div块级元素，不用设置宽度，在水平上自动扩展宽度。包容块是100%，距左侧300，距右侧300。
> 浮动：     缺点：需要考虑清除浮动。浮动是脱离文档流的，处理不好会带来很多问题。优点：兼容性好。
> 绝对定位：     缺点：你的布局已经脱离文档流了，意味着下面的子元素也必须脱离文档流。这个方案的有效性，可使用性是比较差的。优点：快捷，不容易出问题。
> flexbox   缺点： 优点：是为了解决上述两种布局的不足，算是比较完美的一个，在移动端基本都是flex布局
> table    缺点：历史上的诟病。当某一个单元格调整高度的时候，两侧的单元格也是要调整高度的。有的场景是我们不需要同时增高的。 优点：在很多场景是还是非常适用的，比如说在三栏布局中很轻易就做到了。当flex解决不了问题的时候，在pc上考虑兼容IE8，可以使用表格布局
> grid 包容块100% 有行有列 缺点： 优点：所有css框架都在做一些网格的事情，栅格布局12列 .这里不用栅格的话，代码会减少很多
* 如果去掉高度已知，那个不再适用？在不改变的情况下，flex table是可以用的。
浮动情况下文字被左浮动的元素挤开。浮动的时候让文字沿线向下排，不影响左右，答案是创建BFC

## 3-3 页面布局 总结
* 语义化掌握到位
* 页面布局理解深刻
* css基础知识扎实
* 思维灵活且积极上进
* 代码书写规范 
> 页面布局的变通
1. 三栏布局
* 左右宽度固定，中间自适应
* 上下高度固定，中间自适应 (移动端，多想几种方案，优缺点，对比，写个单子)
2. 两栏布局
* 左宽度固定，右自适应
* 右宽度固定，左自适应
* 上宽度固定，下自适应
* 下宽度固定，上自适应

## 3-4 css盒模型一
> css盒模型
1. 基本概念：标准模型+IE模型
2. 标准模型和IE模型区别
3. css如何设置这两种模型
4. js如何设置获取盒模型对应的宽高
5. 拔高 实例题 根据盒模型解释边距重叠
6. BFC 边距重叠解决方案
* 1. content、padding、border、margin
* 2. 标准模型：width是content的宽、  IE模型：width是content + padding + border
* 3. 标准模型：box-sizing:content-box、 IE模型：box-sizing:border-box
* 4. dom.style.width/height 只能取到内联样式的宽高、
     dom.currentStyle.width/height通过3种方式css通过浏览器渲染以后即时运行的一个结果，这个相对准确，只有IE支持、
     window.getComputedStyle(dom).width/height 返回字符串"100px" 通用性兼容性更好、
     dom.getBoundingClientRect().width/height 返回数字100.这个API getBoundingClientRect()使用的场所是计算一个元素的绝对位置，这个绝对位置是根据视窗也就是viewport左顶点的，top left right height width height 根据位置计算出来的
* 5. 父子元素边距重叠、兄弟元素边距重叠(两者中取最大值)、空元素margin-top margin-bottom取最大值
* 6. BFC Block Formatting Contexts (块级格式化上下文)

## 3-5 css盒模型二
` BFC原理，BFC渲染规则：`
  1. BFC元素的垂直方向的边距会发生重叠
  2. BFC的区域不会与浮动元素的box重叠，这个也是用来清除浮动和布局的
  3. BFC在页面中是一个独立的容器，外边的元素不会影响里面的元素，里面的元素也不会影响外边的元素。
  4. 计算BFC高度的时候，浮动元素也会参与计算


`   如何产生BFC？
    float的值不为none。
    overflow的值不为visible。
    position的值不为relative和static。
    display的值为table-cell, table-caption, inline-block中的任何一个。
`


`  BFC的使用场景？`
    那BFC一般有什么用呢？比如常见的多栏布局，结合块级别元素浮动，里面的元素则是在一个相对隔离的环境里运行。
  1. 如果子元素不想有边距重叠问题，就给子元素增加父元素，给父元素创建BFC
  2. 左右两栏布局，左侧定宽高100px左浮动，右侧如果高度超过100px，下方内容会向左侧侵染。这时给右侧容器创建BFC
  3. 清除浮动：子元素浮动的时候，父元素的高度计算没有包含进来。父元素设为BFC后，浮动子元素也会参与到高度计算上来


IFC(Inline Formatting Contexts)直译为"内联格式化上下文"，IFC的line box（线框）高度由其包含行内元素中最高的实际高度计算而来（不受到竖直方向的padding/margin影响)

## 3-6 DOM事件一
* DOM事件的级别
* DOM事件模型
* DOM事件流
* 描述DOM事件捕获的具体流程
* Event对象的常见应用
* 自定义事件

> DOM事件考察：1对事件原理的掌握 捕获冒泡以及流程2注册事件，也就是监听用户的交互行为  3做响应的时候event对象是重要的一部分

-------------------
* DOM事件的级别
DOM1设计的时候没有和事件相关的东西，但是不代表DOM1标准不存在
DOM 0级   element.onclick=function(){}
DOM 2级   element.addEventListener('click',function(){},false) IE有区别
DOM 3级   element.addEventListener('keyup',function(){},false) 只是事件类型增加了很多
-------------------
* DOM事件模型
捕获 冒泡
-------------------
* DOM事件流
例如：用户点击了鼠标左键，这个事件怎么传到页面上，他是怎么响应的
第一阶段：捕获
第二阶段：目标阶段
第三阶段：冒泡
事件通过捕获到达目标元素，这是就是目标阶段，目标元素再上传到window对象也就是冒泡的过程
----------------
* 描述DOM事件捕获的具体流程
捕获：window-document-html-body-...-目标元素
------------------
* Event对象的常见应用
> event.preventDefault()

> event.stopPropagation()

> event.stopImmediatePropagation() 事件响应优先级。一个按钮注册了2个click事件，触发按钮的点击事件，这两个事件都会被分发。在a的响应函数中加这个就会成功的阻止b的执行

> event.currentTarget 当前绑定的事件的对象。这里指的父级元素

> event.target
事件委托:
for循环，里面注册了n多个事件，问你怎么优化？for循环给10个子元素绑定了事件，但是又需要判断当前是哪个子元素被点击了   ，如何获取被点击的元素，就是使用target 
事件代理，将子元素上的事件都转移到父元素上，绑定一次事件就可以了。响应的时候就要区分，当前是那个元素被点击。
-------------------
* 自定义事件
举例：有一个按钮但是不是常规的自定义事件，我想自己给他增加一个事件，我也想在别的地方触发这个事件，而不是用回调的方式去处理，那这个时候就可以用自定义事件了
new Event('custome')
new CustomEvent()
两者的区别 后者不仅可以指定事件名，还可以跟一个object作为指定参数

## 3-7 DOM事件二
页面中事件捕获的流程代码演示
自定义事件的使用

## 3-8 类型转换 升级
* 数据类型
* 显式类型转换
* 隐式类型转换
------------
* 数据类型
原始类型：Boolean Null undefined String Number Symbol 
对象： Object
------------
* 显式类型转换  Number函数
数据类型：
      数值：   转换后还是原来的值
      字符串：如果可以被解析为数值，则转换为相应的数值，否则得到NaN 空字符串转为0
      布尔值：true转为1 false转为0
  undefined：转为NaN
  NULL:转为0
  Number([]) - 0 
  Number({}) - NaN
对象类型转换：
先调用对象自身的valueOf方法，如果该方法返回原始类型的值（数值、字符串和布尔值），则直接对该值使用Number方法，不再进行后续的步骤
如果valueOf方法返回复合类型的值，再调用对象自身的toString方法，如果toString方法返回原始类型的值，则对该值使用Number方法，不在进行后续步骤。
如果toString方法返回的是复合类型的值，则报错

--------------------
* 显式类型转换  String函数
原始类型转换：
      数值：   转为相应的字符串
      字符串：转换后还是原来的值
      布尔值：true转为"true" false转为"false"
  undefined：转为"undefined"
  NULL:转为"null"
  String({}) - "[object Object]"
  String([]) - ""
对象类型转换：
先调用对象自身的toString方法，如果该方法返回原始类型的值（数值、字符串和布尔值），则直接对该值使用String方法，不再进行后续的步骤
如果toString方法返回复合类型的值，再调用对象自身的valueOf方法，如果valueOf方法返回原始类型的值，则对该值使用String方法，不在进行后续步骤。
如果valueOf方法返回的是复合类型的值，则报错

------------------
* 显式类型转换 Boolean函数
数据类型：
  -0
  +0
  NaN
  ''(空字符串)       -》 false
  undefined
  NULL
Boolean([]) - true
Boolean({}) - true

------------
* 隐式类型转换  程序自动的去转换
四则运算
判断语句
Native调用
[]+[]  - ""
[]+{}  - "[object Object]"
{}+[]  - 0      // 认为{}是一个代码块，不执行所以就是 +[],数学中的求值运算，回调Number函数
{}+{}  - chrome "[object Object][object Object]" 字符串相拼接   / Firefox NaN 认为前一个{}是代码块不执行，+{}用Number去转换
true+true - 2
1+{a:1} - "1[object Object]"

## 3-9 HTTP协议类
* HTTP协议的主要特点
* HTTP报文的组成部分
* HTTP方法
* POST和GET的区别
* HTTP状态码
* 什么是持久连接
* 什么是管线化
-----
* HTTP协议的主要特点
简单快速  灵活  无连接  无状态
简单快速 ：每个资源UII是固定的。比如图片和页面地址叫    统一资源定位符是URL。想访问一个资源直接输入URL
灵活： 每个http协议中有个头部分，有一个数据类型，通过一个http协议就可以完成不同数据类型的传输 
无连接：链接一次就会断掉，不会保持链接
无状态：客户端向服务端请求，http协议帮你建立链接，帮你中间传输，一次任务完成后这个链接就断开了，下次客户端再过来服务端是没有办法区分上一次链接和这一次链接是不是同一个人是不是同一个身份

-----
* HTTP报文的组成部分
请求报文：
请求行：包含http方法、页面地址、http协议以及版本    例如：GET/HTTP/1.1
请求头：key-value值 告诉服务端我要哪些内容,要注意什么类型
空行：告诉服务端下一个是请求体不再是请求头
请求体

响应报文：
状态行：例如  HTTP/1.1 200 OK
响应头
空行
响应体
-----
* HTTP方法
GET     获取资源
POST    传输资源
PUT     更新资源
DELETE  删除资源
HEAD    获得报文首部

------
* POST和GET的区别    很重要
GET在浏览器回退时是无害的，而POST会再次提交请求
GET请求会被浏览器主动缓存，而POST不会，除非手动设置 
GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留 （有的公司为了防止CSRF攻击，将请求都是用了post，如果有缓存需要改成get）
GET请求在URL中传送的参数是有长度限制的，而POST没有限制
GET参数通过URL传递，POST放在Request body中

------
* HTTP状态码
1xx：指示信息     -表示请求已接收，继续处理
2xx：成功             -表示请求已被成功接收
3xx：重定向         -要完成请求必须进行更进一步的操作
4xx：客户端错误 -请求有语法错误或请求无法实现
5xx：服务端错误 -服务器未能实现合法的请求

200 OK：
206
301
302  临时重定向
304缓存、
400
401
403 较多 禁止被访问
404 
500
503

-----
* 什么是持久连接
Keep-Alive
http1.1版本
持久连接和非持久连接的区别
-----
* 管线化
在使用持久连接的情况下，
请求1-》响应1-》请求2-》响应2-》请求3-》响应3

管线化：通道是持久建立的 将请求打包传输过去，响应也一次打包传输过来
请求1-》请求2-》请求3-》响应1-》响应2-》响应3

## 3-10 原型链一
* 创建对象有几种方法  3种
* 原型、构造函数、实例、原型链
* instanceof的原理
* new运算符

## 3-11 原型链二
## 3-12 面向对象一
## 3-13 面向对象二
## 3-14 通信类
* 1、什么是同源策略及限制
* 2、前后端如何通讯
* 3、如何创建ajax  借助于第三方库：jq的ajax方法 vue的插件等。动手自己写原生js
* 4、跨域通信的几种方式

## 3-15 安全类
xss
CSRF
基本概念和缩写
攻击原理
预防措施

## 3-16 算法类
思否

## 4-1 渲染机制

## 4-2 js运行机制
js单线程

## 4-3 页面性能
提升页面性能的方法？
1、资源压缩合并，减少HTTP请求  开启gzip压缩
2、非核心代码异步加载 - 异步加载的方式 - 异步加载的区别
* 动态脚本加载
* defer
* async
* 区别：
  defer在HTML解析完之后才会执行。如何多个，按照加载的顺序依次执行
  async在加载完之后立即执行，如果如何多个，执行顺序和加载的顺序无关
3、利用浏览器缓存 - 缓存分类 - 缓存的原理
* 强缓存
    缓存到本地，相当于在本地存储了一个副本，放在电脑磁盘
    http头信息：Expires(服务端的绝对时间和本地时间会有偏差) Cache-Control(相对时间，在这个时间之内不会向服务器请求.如果两个都有以此为准)
    问都不问，直接拿过来用
* 协商缓存
    浏览器发现我的本地有这个副本，但是我不确定用不用他，向服务器询问，这个文件要不要用
  Last-Modified - 时间变了，但是内容没有变化怎么办？就使用Etag
  Last-Modified-Since
  Etag：hash值  对比hash值 查看内容是否变了
  If-None-Match
  
4、使用CDN:加载资源非常快，网络优化    尤其是第一次打开的时候，浏览器缓存是起不到任何作用的。
5、预解析DNS
`<meta http-equiv="x-dns-prefetch-control" content="on"/><link rel="dns-prefetch" href="//host_name_to_prefetch.com"/>
`
link这个标签：DNS预解析
a标签在高级浏览器中是默认打开了DNS预解析的，不用加link这句，也是可以做到的。但是协议是https的，很多浏览器是默认关闭预解析的。
meta这个标签是强制打开DNS预解析
## 4-4 错误监控
* 问：如何检测js错误？
* 如何保证你的产品质量
* 前端错误的分类
        即使运行错误：代码错误
        资源加载错误
* 错误的捕获方式
      即使运行错误：1、try...catch  2、window.onerror(不能用在资源加载错误，因为他不会冒泡)
      资源加载错误： 1、object.onerror(obj是DOM 节点) 2、performance.getEntries()返回数组。可以获取到所有已加载资源的资源时长 ,可以间接的获取未加载的资源 3、Error事件捕获
    延伸：跨域的js运行错误可以捕获吗，错误提示什么，应该怎么处理？
  1、在script标签增加crossorigin属性
  2、设置js资源响应头Access-Control-Allow-Origin:*  或者写专门的域名
* 上报错误的分类
  1、采用Ajax通信上报（可以上报，但是都不采用）
  2、利用Image对象上报 (new Image()).src = 'http://baidu.com/hdudid?w=22'
  
## 4-5 mvvm框架 双向绑定
* 了解MVVM框架吗？ 
 vue react angular
 1. 一定要想好说那个
 2. 收住优点，攒着下面说，开启引导模式 （说：我用过vue；我对vue有深入研究。到此打住）
 3. 话别说的太满，低调谨慎
* 谈谈你对MVVM的认识？
   聊聊MVC，彰显知识面涉猎较多
   把MVVM的定义说清楚，表达概念理解到位
   对比mvvm和mvc（自己对比）
   view(页面，展现形态) -- viewmodel(核心枢纽，data映射到view，和model是ajax通信) -- model(服务器上某一块业务逻辑操作)
* 双向绑定是什么原理，可以写出来吗？
    绑定：自动化处理 不需要手动
    双向： view -反向> data
        <正向-
   
    例如：数据 a=1 修改了a=2，以前的开发，需要拿到DOM节点，再将数据渲染进去。
> mvvm：es5API Object.defineProperty
> 这个API可以监听到data的变化，监听到变化以后有一个回调函数，在定义的时候直接写好回调函数，
> 后续就不需要关心了，在回调函数中写明view和data中某一项数据的关联关系,之后只需要修改data，后续不需要关心
> 反向view->data:input事件，只是不需要我们自己去写了，是框架背后帮你做了这件事
> Object.defineProperty()方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回这个对象
> Object.defineProperty(obj, prop, descriptor) obj要在其上定义属性的对象。 prop要定义或修改的属性的名称。 descriptor 将被定义或修改的属性描述符
> 属性描述符:configurable 可读可修改 ； enumerable枚举，可以使用for...of let..in iterater 取值：get 修改：set
> 在mvvm中 修改data的时候就是触发了set，set检查新的值和旧的值是不是一样，如果不一样就触发这个回调,就是完成了一次赋值检测,也就是说你改变了
> Object.defineProperty用法要熟记于心
> Object.defineProperty(es5返回新对象)与reflect.defineProperty(es6返回布尔值)的区别
> Object.defineProperty要会手写
* 使用了什么设计模式？
* 生命周期是什么？
* 有看过源码吗？（3-4年了）你觉得这个框架的特色是什么？自己收获最大的是什么？



## 4-6 mvvm框架 设计模式
把Object.defineProperty用法熟悉之后再听剩下的课程！！！！！！！！
-----------
观察者模式
监听者：Observer(Object.defineProperty) 监听data发生的变化，变化后会通知所有的观察者列表Dep
观察者列表Dep：data中有个a=1，有好多观察者，说a的变化你要告诉我，我要做处理.数据的变化会触发Object.defineProperty下的set函数，set会对观察者列表的触发。列表中会有一个更新函数，通知了他们他们会自动的调update函数也就是Dep要调回调，这个回调是观察者watcher给的。
观察者watcher：数据变化了以后你要更新，更新什么内容是watcher所定义的。watcher就去更新view。Dep的update是怎么传进去的，就是watcher的订阅
Observer只负责监听这个东西，他怎么知道有谁是观察者列表呢，其实是watcher添加的。他是维护一个列表，列表中有谁他不知道，谁去添加呢就是watcher
data改变了触发set函数，就将Dep循环一遍，通知一遍。每一个列表中调用update

观察者设计模式的原理要了如指掌
最好能写出设计模式的伪代码
如果没有问到设计模式，但是你要展示你的优势

## 4-7 mvvm框架 生命周期
一个对象什么时候可以做什么样的事
vue2.0支持虚拟DOM
new Vue（）
init 初始化 编译
beforeCreate
init
created
beforeMount
mounted（想操作DOM对象的话，做监控通常放在这，页面渲染已经完成）
beforeUpdate （虚拟DOM重新渲染和patch对比的过程叫defer，在对比前触发）
updated（对比完了，页面重新渲染了。测一个点的性能，这里更合适）
beforeDestroy
destroyed
熟记对应的几个节点
熟记每个节点触发的时机
最好多演练一下，写写demo

## 4-8 mvvm框架 源码分析

