<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title></title>
	</head>
	<body>
		<script>
	
//			var fn = new Function('x' ,'console.log(x+5)');
//			fn(3);
//			
//			console.log(a);//情况1、"准备工作" 声明  默认值是undefined
//			var a =10;
//			console.log(this);//情况2、与第一种情况不同的是：第一种情况只是对变量进行声明（并没有赋值），而此种情况直接给this赋值。这也是“准备工作”情况要做的事情之一。
//			console.log(fn1);//情况3、function fn1(){}
//				function fn1(){}//函数声明
//				console.log(fn2);//undefined
//				var fn2=function(){}//函数表达式
//		函数在定义的时候（不是调用的时候），就已经确定了函数体内部自由变量的作用域。
		var a = 10;
		function fn(){
			console.log(a);//a是自由变量。函数创建时，就确定了a要取值的作用域。
		}
		function bar(f){
			var a =20;
			//a = 20;打印20
			f();//打印10 ，而不是20。
		}
		bar(fn);
		</script>
我们总结一下，在“准备工作”中完成了哪些工作：

变量、函数表达式——变量声明，默认赋值为undefined；
this——赋值；
函数声明——赋值；

这三种数据的准备情况我们称之为“执行上下文”或者“执行上下文环境”。
在“准备工作”中，对待函数表达式就像对待“ var a = 10 ”这样的变量一样，只是声明。而对待函数声明时，却把函数整个赋值了。

函数调用次数，会产生许多个上下文环境	

给执行上下文环境下一个通俗的定义——在执行代码之前，把将要用到的所有的变量都事先拿出来，有的直接赋值了，有的先用undefined占个空。
执行全局代码时，会产生一个执行上下文环境，每次调用函数都又会产生执行上下文环境。当函数调用完成时，这个上下文环境以及其中的数据都会被消除，再重新回到全局上下文环境。处于活动状态的执行上下文环境只有一个。

作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。例如以上代码中，三个作用域下都声明了“a”这个变量，但是他们不会有冲突。各自的作用域下，用各自的“a”。

执行全局代码时，会产生一个执行上下文环境，每次调用函数都又会产生执行上下文环境。当函数调用完成时，这个上下文环境以及其中的数据都会被消除，再重新回到全局上下文环境。处于活动状态的执行上下文环境只有一个。
其实这是一个压栈出栈的过程——执行上下文栈。
们所演示的是一种比较理想的情况。有一种情况，而且是很常用的一种情况，无法做到这样干净利落的说销毁就销毁。这种情况就是伟大的——闭包。
	</body>
</html>
